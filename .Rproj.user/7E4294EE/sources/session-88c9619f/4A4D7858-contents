---
title: "TRABAJO INTEGRADOR - INTRODUCCIÓN A LOS MODELOS ESTADÍSTICOS"
author: "GRUPO 01"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    collapsed: true
    smooth_scroll: true
    theme: journal
    highlight: kate
    df_print: paged
    code_folding: show
leng: es-ES
---

# 1. INTEGRANTES DEL GRUPO.
- CYNTHIA MARÍN QUIROZ
- BERNABÉ GONZÁLEZ GARCÍA
- FABIAN ALEXANDER HERRERA AGUAYO
- JHORDY BURGA DOMÍNGUEZ
- ENRIQUE JOSÉ SANCHEZ ARENAS

# 2. CASO ANALIZADO.
## REGISTRO DE MORTALIDAD DE LA REGIÓN SAN MARTÍN.
## 2.1. Resumen del caso.
La data analizada contiene información detallada sobre los eventos de mortalidad ocurridos en la región San Martín, recopilada y gestionada por la Dirección Regional de Salud. Este conjunto de datos incluye variables demográficas, geográficas y clínicas asociadas al fallecimiento de personas.

## 2.2. Fuente.
https://www.datosabiertos.gob.pe/dataset/registro-de-mortalidad-de-la-regi%C3%B3n-san-mart%C3%ADn-%E2%80%93-gore-san-martin-grsm/resource/73aa187a-3cb6

# 3. BASE DE DATOS.
```{r librerias, message=FALSE, warning=FALSE}
# Librerías utilizadas en el proyecto
library(tidyverse)
library(readxl)
library(dplyr)
library(ggplot2)
library(scales)
library(forcats)
library(lubridate)
library(plotly)
library(leaflet)
library(sf)
library(rnaturalearth)
```

```{r carga, message=FALSE, warning=FALSE, rows.print=20}

# Carga del dataset
df_raw <- read.csv("../MORTALIDAD.csv", sep=";")
df_raw

```

## 3.1 Dimensiones del dataset.
```{r dimensiones, echo=FALSE}
# Variable de la fecha de registro
fecha_reg <- as.Date(as.character(df_raw[["FECHA_REGISTRO"]]), format = "%Y%m%d")

# Mensaje de Hallazgo
cat("La data tiene", nrow(df_raw), "filas y", ncol(df_raw), "columnas y el registro va desde el", format(min(fecha_reg, na.rm = TRUE), "%d/%m/%Y"), "hasta el", format(max(fecha_reg, na.rm = TRUE), "%d/%m/%Y"), ". \n")
```

## 3.2. Nombre de las columnas.
```{r cambio_anio, echo=FALSE}
# Cambio de nombre de columna, antes verificamos la existencia de ANIO
if (!"ANIO" %in% names(df_raw)) {
  stop("La columna 'ANIO' no existe en la hoja 1 de MORTALIDAD.xlsx.")
}

# Renombrar ANIO -> AÑO 
df <- df_raw %>%
  dplyr::rename(`AÑO` = ANIO)

# Verificación de los nombres de columnas
names(df)
```

## 3.3. Tipo de variables.
```{r tip_variables, echo=FALSE}
num_vars <- df %>% select(where(is.numeric)) %>% names()
cat_vars <- df %>% select(where(is.character)) %>% names()

cat("Cantidad de variables numéricas:", length(num_vars), "\n")
cat("Nombre de las variables numéricas detectadas:", 
    ifelse(length(num_vars) > 0, paste(num_vars, collapse = ", "), "— (ninguna)"), "\n\n")

cat("Cantidad de variables categóricas:", length(cat_vars), "\n")
cat("Nombre de las variables categóricas detectadas:", 
    ifelse(length(cat_vars) > 0, paste(cat_vars, collapse = ", "), "— (ninguna)"), "\n")
```

## 3.4. valores nulos y duplicados
```{r val_nulos, echo=FALSE}
# Cantidad de valores nulos por columna
df %>% summarise_all(~sum(is.na(.)))
```

```{r val_dupl, echo=FALSE, message=FALSE, warning=FALSE}
# Revisar duplicados
ID <- "IDENTIFICADOR"

if (!ID %in% names(df)) {
  stop("La columna ",ID," no existe en el dataset.")
}

# Número total de registros
n_total <- nrow(df)

# IDs únicos
n_unicos <- n_distinct(df$ID)

# Cantidad de duplicados
n_duplicados <- sum(duplicated(df$ID))

cat("Número total de registros:", n_total, "|| Número de IDs únicos:", n_unicos, "|| Número de filas con ID repetido:", n_duplicados, "  \n")

# Reporte de valores duplicados
if (n_duplicados > 0) {
  cat("\nMuestra IDs repetidos:\n")
  df %>%
    group_by(ID) %>%
    filter(n() > 1) %>%
    arrange(ID) %>%
    head(10) %>%
    print()
} else {
  cat("\nNo se encontraron IDs repetidos en la columna",ID,".\n")
}

```

# 4. ANALISIS EXPLORATORIO
## 4.1 Analisis de Variables numéricas
```{r val_num, echo=FALSE}
df %>% select(all_of(num_vars)) %>% summary()
```

### 4.1.1 Histogramas
```{r val_num_hist, echo=FALSE, fig.width=6, fig.height=4}
# Detectar variables numéricas
num_vars <- df %>% select(where(is.numeric)) %>% names()

# Excluir variables de fecha
excluir <- c("FECHA_REGISTRO", "FECHA_CORTE")
num_vars1 <- setdiff(num_vars, excluir)

# Bucle de gráficos
for (v in num_vars1) {
  
  p_hist <- ggplot(df, aes(x = .data[[v]])) +
    geom_histogram(aes(y = after_stat(count) / sum(after_stat(count))), 
                   bins = 30, fill = "darkorange", alpha = 0.7, color = "black") +
    scale_y_continuous(labels = percent) +
    labs(title = paste("HISTOGRAMA DE", v),
         x = v,
         y = "Frecuencia relativa (%)") +
    theme_minimal()
  
  print(p_hist)
}
```

### 4.1.2 Boxplot
```{r val_num_boxplot, echo=FALSE}
df %>%
  pivot_longer(cols = all_of(num_vars1), names_to = "variable", values_to = "valor") %>%
  ggplot(aes(x = variable, y = valor)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  facet_wrap(~ variable, scales = "free") +
  labs(title = "Boxplots de cada variable numérica") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        strip.text = element_text(face = "bold"))


max_edad <- max(df$EDAD, na.rm = TRUE)
cat(ifelse(max_edad > 120, 
           "Hay edades que superan los 120 años. \n", 
           "Las edades estan dentro del rango de 120 años. \n"))
```

## 4.2 Analisis de Variables categóricas
```{r val_cat, echo=FALSE}
df_tmp <- df

# Excluir columnas no deseadas para graficar
excluir <- c("IDENTIFICADOR", "DEPARTAMENTO", "LATITUD", "LONGITUD")
cat_vars1 <- setdiff(cat_vars, excluir)

# Constante: máximo de categorías a mostrar
level_max <- 20

for (v in cat_vars1) {
  cat("TOP", level_max, "+ OTROS \n")
  tabla <- df_tmp %>%
    mutate(
      categoria_temp = fct_lump_n(.data[[v]], n = level_max, other_level = "OTROS")
    ) %>%
    count(categoria_temp, sort = TRUE) %>%
    mutate(pct = round(100 * n / sum(n), 2)) %>%
    rename(!!v := categoria_temp)
  
  print(tabla)
  cat("\n------------------------------------------------\n")
}
```

### 4.2.1 Histogramas
```{r val_cat_hist, echo=FALSE, fig.width=6, fig.height=4}
# Bucle para graficar cada variable categórica (independiente)
for (v in cat_vars1) {
  
  # Tabla completa de frecuencias (excluye NA y vacío)
  freq_full <- df_tmp %>%
    filter(!is.na(.data[[v]]), .data[[v]] != "") %>%
    count(categoria = .data[[v]], name = "n", sort = TRUE)
  
  # Si no hay categorías válidas, pasar
  if (nrow(freq_full) == 0) next
  
  total_v <- sum(freq_full$n)
  
  # Top N y "OTROS"
  topN <- freq_full %>% slice_head(n = level_max)
  if (nrow(freq_full) > level_max) {
    otros_n <- sum(freq_full$n) - sum(topN$n)
    freq_plot <- bind_rows(
      topN,
      tibble(categoria = "OTROS", n = otros_n)
    )
  } else {
    freq_plot <- topN
  }
  
  # Recalcular porcentaje sobre el total (incluye OTROS si corresponde)
  freq_plot <- freq_plot %>%
    mutate(pct = n / total_v)
  
  # Gráfico de barras independiente
  p <- ggplot(freq_plot, aes(x = fct_reorder(categoria, n), y = n)) +
    geom_col(fill = "seagreen", alpha = 0.85) +
    geom_text(aes(label = percent(pct)), hjust = -0.1, size = 3) +
    coord_flip() +
    expand_limits(y = max(freq_plot$n) * 1.1) +
    labs(
      title = paste(" ", v, "(Top", level_max, " + OTROS)"),
      x = "Categoría", y = "Frecuencia"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold"),
      axis.title.y = element_text(margin = margin(r = 10))
    )
  
  print(p)
}
```

# 5. ANALISIS ESTADISTICO
## 5.1 Mortalidad General
```{r mort_general, echo=FALSE, message=FALSE, warning=FALSE, rows.print=20}
# Verificación de Datos
if (!exists("df_tmp")) stop("El data frame 'df_tmp' no está en el entorno.")
if (!"FECHA_REGISTRO" %in% names(df_tmp)) stop("No existe la columna 'FECHA_REGISTRO' en df_tmp.")

# Convertir YYYYMMDD → Date
df_tmp <- df_tmp %>%
  mutate(FECHA_REGISTRO = ymd(as.character(FECHA_REGISTRO)))

# Agrupar por año
serie_anual <- df_tmp %>%
  group_by(AÑO) %>%
  summarise(Casos = n(), .groups = 'drop')

#Gráfico de tiempo
ggplot(serie_anual, aes(x = AÑO, y = Casos, group = 1)) +
  geom_line(color = "purple", linewidth = 1) +
  geom_point(color = "orange", size = 3) +
  geom_text(aes(label = Casos), vjust = -1, size = 3, fontface = "bold") +
  labs(title = "Fallecimientos por año de registro",
       x = "Año", y = "Número de Casos") +
  theme_minimal() +
  scale_x_continuous(breaks = unique(serie_anual$AÑO))

# Contar casos por año
casos_por_año <- df_tmp %>%
  count(AÑO, name = "Total_Casos") %>%
  arrange(desc(Total_Casos))

# Identificar el año con más casos
año_max_casos <- casos_por_año$AÑO[1]
max_casos <- casos_por_año$Total_Casos[1]
porcentaje_total <- round((max_casos / sum(casos_por_año$Total_Casos)) * 100, 1)

cat("El año", año_max_casos, "registra mayores casos, con un total de:",  max_casos, "que representa el", porcentaje_total, "%. \n")
```

```{r heap_map, echo=FALSE}
# Conversión: YYYYMMDD -> Date (sin alterar df_tmp original) 
if (!exists("df_tmp")) stop("El data frame 'df_tmp' no está en el entorno.")
if (!"FECHA_REGISTRO" %in% names(df_tmp)) stop("No existe la columna 'FECHA_REGISTRO' en df_tmp.")

fechas <- suppressWarnings(ymd(as.character(df_tmp$FECHA_REGISTRO)))

# Diagnóstico rápido
cat("Registros con FECHA_REGISTRO válida:", sum(!is.na(fechas)), "\n\n")

# Agregado Año–Mes (completando combinaciones ausentes con 0)
serie_mes <- tibble(fecha = fechas) %>%
  filter(!is.na(fecha)) %>%
  transmute(anio = year(fecha),
            mes_num = month(fecha),
            mes = month(fecha, label = TRUE, abbr = TRUE)) %>%
  count(anio, mes_num, mes, name = "fallecidos")

if (nrow(serie_mes) > 0) {
  anios <- sort(unique(serie_mes$anio))
  todos <- expand_grid(anio = anios, mes_num = 1:12) %>%
    mutate(mes = month(mes_num, label = TRUE, abbr = TRUE))
  
  serie_mes <- todos %>%
    left_join(serie_mes, by = c("anio","mes_num","mes")) %>%
    mutate(fallecidos = replace_na(fallecidos, 0)) %>%
    arrange(anio, mes_num)
}

# Heatmap Año vs Mes (INTERACTIVO) 
if (nrow(serie_mes) > 0) {
  p <- ggplot(serie_mes, aes(
        x = mes, y = factor(anio), fill = fallecidos,
        text = paste0("Año: ", anio,
                      "<br>Mes: ", mes,
                      "<br>Fallecidos: ", fallecidos)
      )) +
    geom_tile(color = "white", linewidth = 0.3) +
    scale_fill_gradient(low = "lightyellow", high = "red", name = "Fallecidos") +
    labs(
      title = "Fallecidos por Año–Mes (FECHA_REGISTRO)",
      x = "Mes", y = "Año"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 13),
      axis.text.x = element_text(angle = 0, vjust = 0.5),
      panel.grid = element_blank()
    )
  
  # Convertir a interactivo con tooltips personalizados
  ggplotly(p, tooltip = "text")
  
} else {
  cat("No hay datos válidos para construir el heatmap.\n")
}
```

## 5.2 Causas de Mortalidad
```{r causa_mort, echo=FALSE}
# Graficar la mortalidad debido a la causa
stopifnot(exists("df_tmp"))
n_registros <- nrow(df_tmp)
cat("Total de registros (fallecidos):", n_registros, "\n")

# Top 20 causas si existe la columna DEBIDO_CAUSA
if ("DEBIDO_CAUSA" %in% names(df_tmp)) {
  top_causa <- df_tmp %>%
    filter(!is.na(DEBIDO_CAUSA), DEBIDO_CAUSA != "") %>%
    count(DEBIDO_CAUSA, name = "fallecidos", sort = TRUE) %>%
    slice_head(n = level_max)

  # Tabla preliminar
  print(top_causa)

  # Gráfico interactivo
  p <- ggplot(top_causa,
              aes(x = fct_reorder(DEBIDO_CAUSA, fallecidos),
                  y = fallecidos,
                  text = paste0("Causa: ", DEBIDO_CAUSA,
                                "<br>Fallecidos: ", comma(fallecidos)))) +
    geom_col(fill = "steelblue") +
    coord_flip() +
    labs(title = cat("Top", level_max, "causas de fallecimiento"),
         x = "Causa", y = "N° de fallecidos") +
    theme_minimal()

  ggplotly(p, tooltip = "text") %>%
    layout(hoverlabel = list(bgcolor = "black", font = list(color = "white")))
  
} else {
  cat("No existe la columna DEBIDO_CAUSA en el dataset.\n")
}
```

### 5.2.1 Causa vs Sexo
```{r sex_causa, echo=FALSE}
# Graficar SEXO x DEBIDO_CAUSA
# Definir un valor de nivel máximo, ya que las causas son demasiadas
#level_max <- 20   # máximo de causas a mostrar; el resto va a "OTROS"

# Verificación de datos
if (!all(c("SEXO","DEBIDO_CAUSA") %in% names(df_tmp))) {
  stop("Faltan columnas requeridas: 'SEXO' y/o 'DEBIDO_CAUSA' en df_tmp.")
}

# Usamos una Tabla base, pero sin modificar df_tmp
base_tbl <- df_tmp %>%
  filter(!is.na(SEXO), SEXO != "",
         !is.na(DEBIDO_CAUSA), DEBIDO_CAUSA != "") %>%
  mutate(SEXO = as.factor(SEXO),
         DEBIDO_CAUSA = as.character(DEBIDO_CAUSA))

# Top-N causas por frecuencia global
top_causas <- base_tbl %>%
  count(DEBIDO_CAUSA, name = "n", sort = TRUE) %>%
  slice_head(n = level_max) %>%
  pull(DEBIDO_CAUSA)

# Reetiquetar causas no Top-N como "OTROS"
base_tbl <- base_tbl %>%
  mutate(DEBIDO_CAUSA_TOP = if_else(DEBIDO_CAUSA %in% top_causas, DEBIDO_CAUSA, "OTROS"))

# Tabla cruzada SEXO × DEBIDO_CAUSA_TOP 
tabla_sc <- base_tbl %>%
  count(SEXO, DEBIDO_CAUSA_TOP, name = "fallecidos") %>%
  group_by(DEBIDO_CAUSA_TOP) %>%
  mutate(pct_en_causa = fallecidos / sum(fallecidos)) %>%   # % dentro de cada causa
  ungroup()

# Mostrar tabla completa
print(tabla_sc, n = nrow(tabla_sc))

# HEATMAP interactivo: SEXO × DEBIDO_CAUSA_TOP
p_heat <- ggplot(
  tabla_sc,
  aes(x = SEXO,
      y = fct_reorder(DEBIDO_CAUSA_TOP, fallecidos, .fun = sum),
      fill = fallecidos,
      text = paste0("Causa: ", DEBIDO_CAUSA_TOP,
                    "<br>Sexo: ", SEXO,
                    "<br>Fallecidos: ", comma(fallecidos),
                    "<br>% dentro de la causa: ", percent(pct_en_causa, accuracy = 0.1)))
) +
  geom_tile(color = "white", linewidth = 0.3) +
  scale_fill_gradient(low = "lightyellow", high = "red", name = "Fallecidos") +
  labs(title = paste0("SEXO × DEBIDO_CAUSA (Top ", level_max, " + OTROS)"),
       x = "SEXO", y = "DEBIDO_CAUSA") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        axis.text.y = element_text(size = 7))

ggplotly(p_heat, tooltip = "text") %>%
  layout(hoverlabel = list(bgcolor="black", font=list(color="white")))

# BARRAS APILADAS interactivas (ordenadas por total de causa) ---
tabla_stack <- tabla_sc %>%
  group_by(DEBIDO_CAUSA_TOP) %>%
  mutate(total_causa = sum(fallecidos)) %>%
  ungroup()

p_stack <- ggplot(
  tabla_stack,
  aes(x = fct_reorder(DEBIDO_CAUSA_TOP, total_causa),
      y = fallecidos,
      fill = SEXO,
      text = paste0("Causa: ", DEBIDO_CAUSA_TOP,
                    "<br>Sexo: ", SEXO,
                    "<br>Fallecidos: ", comma(fallecidos),
                    "<br>Total causa: ", comma(total_causa),
                    "<br>% dentro de la causa: ", percent(pct_en_causa, accuracy = 0.1)))
) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(labels = comma) +
  labs(title = paste0("SEXO × DEBIDO_CAUSA (Top ", level_max, " + OTROS)"),
       x = "DEBIDO_CAUSA", y = "N° de fallecidos", fill = "SEXO") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        axis.text.y = element_text(size = 7))

ggplotly(p_stack, tooltip = "text") %>%
  layout(hoverlabel = list(bgcolor="black", font=list(color="white")))
```

## 5.3 Mortalidad por etapa
```{r mort_etapa, echo=FALSE}
# Validación de datos
stopifnot(exists("df_tmp"))
if (!"ETAPA" %in% names(df_tmp)) stop("No existe la columna 'ETAPA' en df_tmp.")

# Tabla de mortalidad por ETAPA
tabla_etapa <- df_tmp %>%
  filter(!is.na(ETAPA), ETAPA != "") %>%
  count(ETAPA, name = "fallecidos", sort = TRUE) %>%
  mutate(pct = fallecidos / sum(fallecidos))

# Mostrar tabla completa
#print(tabla_etapa, n = nrow(tabla_etapa))
print(tabla_etapa, n = nrow(tabla_etapa), na.print = "")

# Gráfico de barras (ordenado) + tooltip
p <- ggplot(
  tabla_etapa,
  aes(x = fct_reorder(ETAPA, fallecidos), y = fallecidos,
      text = paste0(
        "ETAPA: ", ETAPA,
        "<br>Fallecidos: ", comma(fallecidos),
        "<br>% del total: ", percent(pct, accuracy = 0.1)
      ))
) +
  geom_col(fill = "#4C78A8") +
  coord_flip() +
  labs(title = "Mortalidad total por ETAPA",
       x = "ETAPA", y = "N° de fallecidos") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        axis.text.y = element_text(size = 9))

# Interactividad y estilo del tooltip
ggplotly(p, tooltip = "text") %>%
  layout(hoverlabel = list(bgcolor = "black", font = list(color = "white")))
```

### 5.3.1 Sexo vs Etapa
```{r sex_etapa, echo=FALSE}
# Validación de datos
stopifnot(exists("df_tmp"))
if (!all(c("ETAPA","SEXO") %in% names(df_tmp))) stop("Faltan columnas 'ETAPA' y/o 'SEXO' en df_tmp.")

# Base limpia (sin NA/""), con normalización ligera de SEXO (opcional)
base_tbl <- df_tmp %>%
  filter(!is.na(ETAPA), ETAPA != "", !is.na(SEXO), SEXO != "") %>%
  mutate(
    SEXO = case_when(
      toupper(SEXO) %in% c("M", "MASCULINO") ~ "MASCULINO",
      toupper(SEXO) %in% c("F", "FEMENINO")  ~ "FEMENINO",
      TRUE ~ as.character(SEXO)
    )
  )

# Tabla: ETAPA x SEXO, con totales y % dentro de ETAPA
tabla_es <- base_tbl %>%
  count(ETAPA, SEXO, name = "fallecidos") %>%
  group_by(ETAPA) %>%
  mutate(
    total_etapa   = sum(fallecidos),
    pct_en_etapa  = fallecidos / total_etapa
  ) %>%
  ungroup()

# Mostrar tabla completa
print(tabla_es, n = nrow(tabla_es))

# Gráfico de barras apiladas (ordenado por total de ETAPA)
p <- ggplot(
  tabla_es,
  aes(
    x = fct_reorder(ETAPA, total_etapa),
    y = fallecidos,
    fill = SEXO,
    text = paste0(
      "ETAPA: ", ETAPA,
      "<br>Sexo: ", SEXO,
      "<br>Fallecidos: ", comma(fallecidos),
      "<br>Total ETAPA: ", comma(total_etapa),
      "<br>% dentro de ETAPA: ", percent(pct_en_etapa, accuracy = 0.1)
    )
  )
) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Fallecidos por ETAPA y SEXO",
    x = "ETAPA", y = "N° de fallecidos", fill = "SEXO"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"),
        axis.text.y = element_text(size = 9))

# Interactividad + tooltip negro/blanco
ggplotly(p, tooltip = "text") %>%
  layout(hoverlabel = list(bgcolor = "black", font = list(color = "white")))
```

## 5.3 Relación provincia vs Sexo
```{r prov_sex, echo=FALSE}
# BARRAS APILADAS
# Validación de datos
if (all(c("SEXO","PROVINCIA") %in% names(df_tmp))) {
  
  # Tabla cruzada con porcentaje dentro de la provincia
  tabla_sp <- df_tmp %>%
    filter(!is.na(SEXO), !is.na(PROVINCIA)) %>%
    count(PROVINCIA, SEXO, name = "fallecidos") %>%
    group_by(PROVINCIA) %>%
    mutate(pct = fallecidos / sum(fallecidos)) %>%
    ungroup()
  
  # ggplot con estética y tooltip personalizados
  p <- ggplot(
      tabla_sp,
      aes(
        x = SEXO,
        y = fct_reorder(PROVINCIA, fallecidos, .fun = sum),  # orden por total provincial
        fill = fallecidos,
        text = paste0(
          "Provincia: ", PROVINCIA,
          "<br>Sexo: ", SEXO,
          "<br>Fallecidos: ", comma(fallecidos),
          "<br>% en provincia: ", percent(pct, accuracy = 0.1)
        )
      )
    ) +
    geom_tile(color = "white", linewidth = 0.3) +
    scale_fill_gradient(low = "lightyellow", high = "red", name = "Fallecidos") +
    labs(
      title = "Fallecidos por SEXO y PROVINCIA",
      x = "SEXO", y = "PROVINCIA"
    ) +
    theme_minimal() +
    theme(axis.text.y = element_text(size = 8),
          plot.title = element_text(face = "bold"))
  
  # Interactivo con plotly (usa el tooltip definido en aes(text=...))
  ggplotly(p, tooltip = "text")
  
} else {
  cat("El dataset no contiene las columnas SEXO y PROVINCIA.\n")
}
```

```{r prov_sex2, echo=FALSE}
# BARRA HORIZONTAL
if (all(c("SEXO","PROVINCIA") %in% names(df_tmp))) {

  tabla_sp <- df_tmp %>%
    filter(!is.na(SEXO), !is.na(PROVINCIA)) %>%
    count(PROVINCIA, SEXO, name = "fallecidos") %>%
    group_by(PROVINCIA) %>%
    mutate(pct = fallecidos / sum(fallecidos),
           total_prov = sum(fallecidos)) %>%
    ungroup()

  p_bar <- ggplot(
      tabla_sp,
      aes(
        x = fct_reorder(PROVINCIA, total_prov),
        y = fallecidos,
        fill = SEXO,
        text = paste0(
          "Provincia: ", PROVINCIA,
          "<br>Sexo: ", SEXO,
          "<br>Fallecidos: ", comma(fallecidos),
          "<br>Total provincia: ", comma(total_prov),
          "<br>% en provincia: ", percent(pct, accuracy = 0.1)
        )
      )
    ) +
    geom_col() +
    coord_flip() +
    scale_y_continuous(labels = comma) +
    labs(
      title = "Fallecidos por SEXO y PROVINCIA",
      x = "PROVINCIA", y = "N° de fallecidos", fill = "SEXO"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold"),
      axis.text.y = element_text(size = 8)
    )

  # Convertir a interactivo y personalizar tooltip
  ggplotly(p_bar, tooltip = "text") %>%
    layout(
      hoverlabel = list(
        bgcolor = "black",   # fondo negro
        font = list(color = "white")  # texto blanco
      )
    )
}
```